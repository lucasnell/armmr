# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Multiple populations simulated using AR1 process.
#'
#' Input and output N values are logged.
#' All input matrices other than `X` and `vcv_cube` should have rows associated
#' with a given species and columns associated with a given location.
#' See descriptions for `X` and `vcv_cube`.
#'
#' @param X Matrix of environmental variable.
#'     It should have rows associated with a given time point and
#'     columns associated with a given location.
#' @param N0_mat Matrix of starting population abundances (`log(# individuals)`)
#'     by species and location.
#' @param b0_mat Matrix of \eqn{\beta_0} (the population-abundance intercept) values
#'     by species and location.
#' @param b1_mat Matrix of \eqn{\beta_1} (the effect of \eqn{X} on \eqn{N}) values
#'     by species and location.
#' @param rho_mat Matrix of growth rates by species and location.
#' @param vcv_cube Cube representing variance-covariance matrices for process error
#'     among species, one matrix for each location.
#'     It should have rows and columns associated with a given species,
#'     and slices associated with a given location.
#' @param obs_sigma Vector of standard deviations of observation error for each species.
#' @param n_cores Number of cores to use. Defaults to 1.
#'
#'
#'
#' @return A 3-dimensional array.
#' The output will have rows associated with a given time point,
#' columns associated with a given species, and
#' slices associated with a given location.
#'
#'
#'
#'
#' @export
#'
#' @examples
#' X <- matrix(rlnorm(20), 10)
#' N0 <- matrix(rep(log(10), 6), 3, 2)
#' b0 <- matrix(rep(log(100), 6), 3, 2)
#' b1 <- matrix(rep(0.1, 6), 3, 2)
#' rho <- matrix(rep(0.2, 6), 3, 2)
#' vcv <- diag(3)
#' vcv[lower.tri(vcv)] <- vcv[upper.tri(vcv)] <- 0.1
#' vcv <- array(vcv, dim = c(3, 3, 2))
#' obs <- rep(0.1, 3)
#' sim_pops_ar(X, N0, b0, b1, rho, vcv, obs)
#'
sim_pops_ar <- function(X, N0_mat, b0_mat, b1_mat, rho_mat, vcv_cube, obs_sigma, n_cores = 1L) {
    .Call(`_lizard_sim_pops_ar`, X, N0_mat, b0_mat, b1_mat, rho_mat, vcv_cube, obs_sigma, n_cores)
}

#' Melt a cube into a single data frame.
#'
#' @param C Three-dimensional array that you want to melt into a two-dimensional
#'     data frame.
#'
#' @return A melted data frame.
#'
#' @noRd
#'
melt_cube <- function(C) {
    .Call(`_lizard_melt_cube`, C)
}

#' Generate data for simulations.
#'
#' Generate multi-location, multi-species time series data.
#'
#'
#' @param n_time Number of time steps.
#' @param n_loc Number of locations.
#' @param n_spp Number of species.
#' @param mean_b0 Mean for the b0 parameter relating X to N.
#' @param mean_b1 Mean for the b1 parameter relating X to N.
#' @param mean_rho Mean for the rho parameter relating X to N.
#'     This parameter is on the inverse logit scale.
#' @param sigma_b0 Standard deviation for the b0 parameter relating X to N.
#' @param sigma_b1 Standard deviation for the b1 parameter relating X to N.
#' @param sigma_rho Standard deviation for the rho parameter relating X to N.
#'     This parameter is on the inverse logit scale.
#' @param sigma_eps Standard deviation for the epsilon parameter.
#' @param sigma_obs Standard deviation for observation error. Defaults to 0.
#' @param corr_method Method for determining correlations between species.
#'     Options are "none", "phylo", or "random". Defaults to "none".
#'
#'
#' @export
#'
#' @examples
#' generate_data(10, 2, 3,
#'               mean_b0 = log(100),
#'               mean_b1 = 0.1,
#'               mean_rho = 0.25,
#'               sigma_b0 = 0.1,
#'               sigma_b1 = 0.1,
#'               sigma_rho = 0.1,
#'               sigma_eps = 0.1)
#'
#'
generate_data <- function(n_time, n_loc, n_spp, mean_b0, mean_b1, mean_rho, sigma_b0, sigma_b1, sigma_rho, sigma_eps, sigma_obs = 0, corr_method = "none") {
    .Call(`_lizard_generate_data`, n_time, n_loc, n_spp, mean_b0, mean_b1, mean_rho, sigma_b0, sigma_b1, sigma_rho, sigma_eps, sigma_obs, corr_method)
}

#' Simulate populations with competition.
#'
#' This does most of the work for the R-exported function below.
#'
#' @param N Output matrix of population abundances.
#' @param distr Normal distribution generator from C++ STL.
#' @param eng pcg32 object that generates random numbers.
#' @inheritParams sim_pops
#'
#'
#' @noRd
#'
NULL

#' Simulate populations with competition.
#'
#' @param max_t Number of time points to simulate.
#' @param N0 Vector of starting population abundances, one for each species.
#' @param r Vector of growth rates, one for each species.
#' @param alpha Matrix of intra- and inter-specific density dependences.
#' @param sigma Standard deviation of process error.
#'
#'
#' @export
#'
#' @examples
#' sim_pops(10, c(10, 10), c(0.5, 0.5), matrix(rep(1e-3, 4), 2, 2), 0.25)
#'
sim_pops <- function(max_t, N0, r, alpha, sigma) {
    .Call(`_lizard_sim_pops`, max_t, N0, r, alpha, sigma)
}

